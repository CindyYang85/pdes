#header<<

// See copyright notice in file Copyright in the root directory of this archive.

#include <utils/ConfigurationScope.h>
#include <utils/ConfigurationValue.h>
#include <utils/ConfigurationChoice.h>
#include <vector>
#include <cstdio>
#include <utils/Debug.h>
>>

<<
// Base info for DLG-generated scanner
#include "DLexerBase.h"

// The scanner generated by DLG from this file
#include "ConfigurationLexer.h"

// Base token definitions for ANTLR
#include "AToken.h"

// Define your token type (ANTLRToken) as just ANTLRCommonToken
// (basically just token type and text
typedef ANTLRCommonToken ANTLRToken;

const ConfigurationScope *
ConfigurationParserHandle::parseFile( const string &fileName ){
  const ConfigurationScope *outerScope = 0;

  // define input file; standard input for this one
  const char *filename = fileName.c_str();
  FILE *inputFile = fopen( filename, "r" );

  if( inputFile != 0 ){
    DLGFileInput in( inputFile );
    
    // define an instance of your scanner
    ConfigurationLexer scanner(&in);
    
    // define token buffer between scanner and parser
    ANTLRTokenBuffer pipe(&scanner);
    
    // create a token to use as a model
    ANTLRToken tok;
    
    // tell the scanner what type the token is
    scanner.setToken(&tok);
    
    // create an instance of your parser
    ConfigurationParserHandle myParser(&pipe);
    
    // initialize your parser
    myParser.init();
  
    // start first rule
    outerScope = myParser.configurationFile();
    if( outerScope != 0 &&
	outerScope->findChoice("DEBUG") != 0 &&
	stringCaseCompare( outerScope->getStringValue("DEBUG"), "TRUE" )){
      utils::enableDebug();
    }
  }
  else{
    string error = "Error reading configuration file \"" + fileName + "\"";
    perror( error.c_str() );
  }

  return outerScope; 
}
>>

#lexclass START

// Whitespace start

#token "[\ \t]" <<skip();>>
#token "[\n\r]" <<skip(); newline();>>

// Allow bash comments
#token "# ~[\n@]* [\n@]" <<skip(); newline();>>
#token "; ~[\n@]* [\n@]" <<skip(); newline();>>

// Here are the meaningful tokens

#token "\"" << skip(); mode(STRING); >>
#token IDENTIFIER("identifier") "[a-zA-Z]+[0-9]*"
#token INTEGERVAL("integer") "{[\-]}[0-9]+"
#token FLOATVAL("float") "{[\-]}[0-9]+.{[0-9]}*"
#token COMMA(",") ","
#token COLON(":") ":"
#token LBRACE("{") "\{"
#token RBRACE("}") "\}"
#token END("EOF") "@"

#lexclass STRING
#token STRINGLIT "\"" << // truncate quote
                         replchar('\0');
                         mode(START);
                       >>
#token "~[]" <<more();>>

#tokclass STRING_LITERAL { STRINGLIT IDENTIFIER }

class ConfigurationParserHandle {
<<
public:
  void init(){
    ANTLRParser::init();
  }

  static const ConfigurationScope *parseFile( const string &fileName );
>>

configurationFile > [ const ConfigurationScope *outerScope ]:
  <<
  ConfigurationScope *retval = new ConfigurationScope( "" );
  >>
  nested_configuration[ retval ]
  END
  <<
    $outerScope = retval;
  >>
;

nested_configuration[ ConfigurationScope *outerScope ]:
  ((IDENTIFIER COLON)?config_value[outerScope]
   | configuration_scope[outerScope])*
;

configuration_scope[ ConfigurationScope *outerScope ]:
  <<
    ConfigurationScope *newScope = 0;
  >>
  id:IDENTIFIER
  <<
    newScope = new ConfigurationScope( id->getText() );
    outerScope->addScope( newScope );
  >>
  LBRACE
  nested_configuration[ newScope ]
  RBRACE
;

config_value[ ConfigurationScope *outerScope ]:
  <<
    ConfigurationValue *firstValue = 0;
    ConfigurationValue *nextValue = 0;
    ConfigurationChoice *newChoice = 0;
    vector<const ConfigurationValue *> *myVector = 0;
  >>
  id:IDENTIFIER COLON
  <<
    newChoice = new ConfigurationChoice( id->getText() );
  >>
  value > [ firstValue ]
  { 
    (COMMA
     value > [ nextValue ]
     <<
      if( myVector == 0 ){
        myVector = new vector<const ConfigurationValue *>;
        myVector->push_back( firstValue );
      }
      myVector->push_back( nextValue );
    >>
    )*
  }
  <<
    if( myVector == 0 ){
      newChoice->setConfigurationValue( firstValue );
    }
    else{
      newChoice->setConfigurationValue( new VectorConfigurationValue( myVector ) );
    }
    outerScope->addChoice( newChoice );
  >>
;

value > [ConfigurationValue *retval]:
  <<
    $retval = 0;
  >>
  (
    strng:STRING_LITERAL
    <<
      $retval = new StringConfigurationValue( strng->getText() );
    >>
    |
    inttok:INTEGERVAL
    <<
      $retval = new IntConfigurationValue( inttok->getText() );
    >>
    |
    floattok:FLOATVAL
    <<
      $retval = new DoubleConfigurationValue( floattok->getText() );
    >>
  )
;
